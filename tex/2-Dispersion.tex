%!TEX root = ../../Bachelorseminar-RoboticSwarms.tex
We consider dispersion as one of the key sub-problems needed to be solved in Robotic Swarms.\cite{ugur2007dispersion,mclurkin2007distributed,ludwig2006robotic} Dispersion can be compared to the blanket coverage problem, which was defined by in one of the first papers written on the topic of swarm robots: \emph{Command Control for Many-Robot Systems}.\cite{gage1992command} The objective of blanket coverage is defined as ``achieving a static arrangement of elements that maximizes the detection rate of targets appearing within the coverage area.''\cite{gage1992command} The difference between dispersion and formation is often confused. While formation is trying to maintain explicitly specified spacing relationships, dispersion tries to find the best ``formation'' for the current environment. 

\subsection{Applications}
Due to the fact that dispersion is one of the fundamental sub-problems in robotic swarms, it has a great number of applications.
Some of these applications include, but are not limited to exploration, surveillance, military response, disaster response and planetary exploration.\cite{ludwig2006robotic,Penders2011,mclurkin2007distributed} 

\subsection{Algorithms}
In this section we will discuss a few categories of approaches which are used to solve the dispersion problem.
Further we will motivate as to why the algorithms was put into a specific category and we will discuss the scalability and performance for each type of algorithm.
For more information on the operation of the mentioned algorithms, please consult the references.

\subsubsection{Brute-Force Approach}
Under the brute-force approach we categorize algorithms such as \emph{random-walk} and \emph{follow-wall} algorithms.\cite{morlok2007dispersing} 
The base of these algorithms are location-free, but often include collision detection which makes them range-based.
The scalibility of the algorithms in this category differs greatly.
Random-walk for instance is known as one of the most scalable algorithms, due to its independence of other robots in the swarm.
On the other hand the performance of the follow-wall algorithm deteriorates greatly when increasing the scale. 
This due to the fact that they can not easily distinguish between the wall and other objects and thus creates the possiblity for the swarm-bots to circle around each other.

\subsubsection{Graph Theory Approach}
The algorithms which are inspired by graph theory can be divided into two sub-categories: algorithms inspired by tree search algorithms and algorithms inspired by connectivity in graphs.\\

In a paper on algorithms for rapidly dispersing robot swarms in unkown environments\cite{hsiang2004algorithms}, two tree search inspired algorithms were named.
The paper mentions two strategies: \emph{Depth-First Leader-Follower(DFLF)} Strategy and the \emph{Breadth-First Leader-Follower} Strategy.
The implementation of these algorithms are mainly considered as \emph{location-based} algorithms, due to the fact that they work with grids which require absolute or relative positioning.
Performance wise the DFLF algorithm requires less moves compared to the BFLF algorithm, but it is also a more complex algorithm.
Due to the high amount of computation which needs to be done centrally, the scalibility of this type of algorithms are rather low.
Every robot has to be taken care of by one or multiple robots. By centralizing this computation, there is a greater risk of something going wrong compared to decentralized control.\\

One of the algorithms regarding connectivity in graphs is the clique-intensity algorithm.\cite{ugur2007dispersion}
The clique-intensity algorithm is range-based since it measures and uses the distance between itself and other surrounding swarm-bots.
The performance and scalability of the algortihm is very high, due to decentralized control.

\subsubsection{Inverse-Vector Approach}
Some examples of the inverse-vector approach are the seek-open algorithm\cite{morlok2007dispersing}, the fiducial algorithm\cite{morlok2007dispersing} and the uniform directed dispersion(UDD) algorithm\cite{mclurkin2007distributed}.
Each of the algorithms basically senses where obstacles and other swarm-bots are relatively positioned and calculates a vector of that data. Afterwards it calculates the inverse of that vector and moves into that direction.
The fiducial algorithm uses a beacon system. The seek-open and UDD algorithm use other distance measures mostly using ultrasonic sensors. In both cases the algorithm is an range-based algorithm, where every robot is able to get the relative location. 

  \begin{table}[H]
  \renewcommand{\arraystretch}{1.3}
  \caption{Overview of Common Dispersion Algorithms}
  \label{table_alg_dispersion}
  \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    \bfseries Algorithm & \bfseries Type & \bfseries Performance & \bfseries Scalability\\
    \hline
    \bfseries DFLF& Location-Free & Medium-High & High\\\hline
    \bfseries BFLF & Location-Free & High & High\\\hline
    \bfseries Directed Dispersion & Range-Based & Medium & High\\\hline
    \bfseries Random Walk& Range-Based & Medium & High\\\hline
    \bfseries Follow Wall& Range-Based & Low & Low\\\hline
    \bfseries Seek Open& Range-Based & Low & Medium\\\hline
    \bfseries Fiducial& Range-Based & Medium & High\\\hline
    \bfseries Clique-Intensity& Range-Based & High & High\\\hline
    \end{tabular}
  \end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Todo: Problems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Problems}
  \textbf{Range-Based}

  Starting from the simpler Algorithms such as random walk and wall following, we show the problems that the dispersion technique has faced in the past and how the newer algorithms have solved these problems. The \emph{Random Walk} algorithm has to be one of the simpelest algorithms, the problem this algorithm faces though, is that dispersiveness of the robots does not guarantee uniform dispersion. The algorithm can be seen as a brute-force approach, it possibly achieves our end-goal, but it does not do this in an optimal and scalable way.

  \emph{Wall Following} is an algorithm which is used a lot in robotic swarms, however it is not very effective by itself and faces many problems with scalability.  One of the main problems with scalability is the fact that the robot does not distinguish other robots and actual walls. This causes an extereme amount of collisions and thus with large amounts of robots, this algorithm becomes near to useless. 

  The \emph{Seek Open} algorithm is a good example of the real usage of Range-Based navigation, due to the fact that it actually uses the magnitudes of the data provided and does calculations in order to find the best position to move towards. The problem that this algorithm faces however is that it should be implemented with a collision avoidance algorithm. The algorithm is not really adapted to work with other dynamic objects, such as other robots. It is therefore not a very scalable algorithm by itself.

  The \emph{Fiducial} algorithm uses the Random Walk algorithm. A problem with the Random Walk algorithm has been solved here: the beacon like system, prevents the robots from running into each other. The Fiducial algorithm does not have any specific problems, however it still is a brute-force approach and thus does not guarantee uniform dispersion.

  The main problem with the \emph{Clique-Intensity} algorithm is the fact that due to high amounts of noise in the wireless intensity signals there is a lot of uncertainty in some real world applications. In a perfect situation, the algorithm would also work near perfectly. The work in this area has mostly been theoretical, real-world application is very different compared to theoretical situations.\\

  \textbf{Location-Free}

  The \emph{BFLF} algorithm, requires the robots to travel less compared to the \emph{DFLF} algortihm. The DFLF algorithm is furthermore also more computationally expensive than the DFLF algorithm. There is no big difference further during the execution of both algorithms, and thus BFLF has the preference. The problems that these types of algorithms face are not theoretical, but are coming forth from the category that they're in: often it is impossible to know the exact location, even if it's relative. There are quite a few ways that people try to achieve to create a relative position grid, however it difficult if not impossible to achieve in many real world applications.\\

\subsubsection{Remaining-Problems}
  The remaining problems in dispersion algorithms can be generally categorized into range-based problems and location-free problems, since all of the algorithms that are in these categories, are facing similar problems.
  The focus needed for the range-based approach needs to be on the uniformity of the dispersion. So how can we guarantee uniformity when dispersing the robots.
  The focus needed for location-free approaches is: how do we actually implement this in real world applications. There are minor to no problems in theory, however to actually bring the relative positioning into a grid is quite difficult. Research in this area should be focussed on how to create these relative positioning grids into a dependable and accurate manner.
